<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于MySQL 8的特性实现拉模型的消息队列</title>
    <url>/2020/12/17/project/mysql8-mq/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="mysql-8-新特性"><a class="markdownIt-Anchor" href="#mysql-8-新特性"></a> mysql 8 新特性</h2>
<p>MySQL 8增加了 <strong>Locking Read Concurrency with NOWAIT and SKIP LOCKED</strong> 的实现<br />
官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html" target="_blank" rel="noopener">mysql8 15.7.2.4 Locking Reads</a></p>
<h2 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h2>
<p>  普通的消息队列就是由生产者与消费者组成，多数场景下数据都会先落库然后将消息发送到消息队列，等待消费者进行消费。消费者在消费的时候往往需要保证执行的成功性，如果失败则需要进行n次重试。在某些场景下还需要事务消息的存在，需要保证消息与数据库写入同时成功。<br />
  在一些小型项目内完全没有必要引入体量巨大的消息队列中间件，但多数项目都有数据库的依赖。所以直接使用mysql进行消息队列实现可以简化某些项目的体量。</p>
<h1 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h1>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<p>使用单表记录存放消息<br />
结构：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int(11)</td>
<td>主键</td>
</tr>
<tr>
<td>topic</td>
<td>varchar(64)</td>
<td>主题</td>
</tr>
<tr>
<td>key</td>
<td>varchar(64)</td>
<td>消息唯一性</td>
</tr>
<tr>
<td>status</td>
<td>int(11)</td>
<td>消费状态</td>
</tr>
<tr>
<td>retry</td>
<td>int(11)</td>
<td>剩余重试次数</td>
</tr>
<tr>
<td>start_time</td>
<td>bigint(20)</td>
<td>任务最小开始执行的时间</td>
</tr>
<tr>
<td>exception</td>
<td>varchar(11)</td>
<td>错误内容</td>
</tr>
<tr>
<td>msg</td>
<td>varchar(256)</td>
<td>消息主体</td>
</tr>
</tbody>
</table>
<p>建立唯一索引1(topic, key, retry)，建立普通索引2(topic, status, start_time)<br />
状态分为：0（未消费），1（消费失败），2（消费成功）</p>
<h2 id="处理逻辑"><a class="markdownIt-Anchor" href="#处理逻辑"></a> 处理逻辑</h2>
<h3 id="查找可以消费的消息"><a class="markdownIt-Anchor" href="#查找可以消费的消息"></a> 查找可以消费的消息</h3>
<p>先开启事务，查找可以消费的消息，指定Topic，指定状态是待消费，开始时间小于等于当前时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> task <span class="keyword">WHERE</span> topic=<span class="string">'topic1'</span> <span class="keyword">status</span>=<span class="number">0</span> <span class="keyword">AND</span> start_time&lt;=<span class="number">1608212942</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">SKIP</span> <span class="keyword">LOCKED</span>;</span><br></pre></td></tr></table></figure>
<h3 id="消费成功"><a class="markdownIt-Anchor" href="#消费成功"></a> 消费成功</h3>
<p>更新状态为3，表示消费成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> task <span class="keyword">SET</span> <span class="keyword">status</span>=<span class="number">3</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="消费失败"><a class="markdownIt-Anchor" href="#消费失败"></a> 消费失败</h3>
<p>更新状态为2，表示当前消息消费失败<br />
检查当前retry是否大于0，若大于0，则插入一条新的消息，状态为0，retry-1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> task <span class="keyword">SET</span> <span class="keyword">status</span>=<span class="number">2</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<h3 id="异常退出"><a class="markdownIt-Anchor" href="#异常退出"></a> 异常退出</h3>
<p>若消费者在消费期间异常退出，则事务会被rollback，那么最多当前消费行为被当做无效行为，但可以保证会被下一个消费者重试，但无法保证重试次数是有效的。但异常退出本身就是少数情况，正常情况下的代码逻辑异常都会被捕获，不会导致该情况发生。</p>
<h1 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h1>
<p>由于是通过事务来进行的行锁，所以在逻辑调用的时候要防止内部逻辑中有数据库操作导致的关联rollback，最好开启多个session进行数据库操作</p>
<h1 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h1>
<p>消息拉取的SQL会走索引2，所以在mysql8的innodb引擎中，会命中行锁，所以不会产生并发问题，但由于整个消费期间事务不会被释放，所以会有大量的事务和链接保持，会数据库有一定的性能影响，具体影响有多少未进行测试。这个设计也仅仅是一个轻量级的拉模式消息队列实现，至少保证了事务一定会被消费成功。<br />
后续有时间会进行简单的性能测试。</p>
<h1 id="额外"><a class="markdownIt-Anchor" href="#额外"></a> 额外</h1>
<p>基于这个表还可以实现消费结果的存放</p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络复习笔记</title>
    <url>/2019/12/05/study/network/</url>
    <content><![CDATA[<h1 id="第一章-概述"><a class="markdownIt-Anchor" href="#第一章-概述"></a> 第一章 概述</h1>
<h2 id="11-计算作用"><a class="markdownIt-Anchor" href="#11-计算作用"></a> 1.1 计算作用</h2>
<ol>
<li>21世纪的一些重要特征：<strong>数字化、网络化、信息化</strong>。</li>
<li>网络分类：<strong>电信网络，有线电视网络，计算机网络</strong></li>
<li>互联网两个基本特性：<strong>连通性</strong>和<strong>共享</strong></li>
<li>连通性：互联网使上网用户之间不管相距多远，都可以非常便捷非常经济地交换各种信息</li>
<li>共享：资源共享，包括信息共享，软件共享，硬件共享。</li>
</ol>
<h2 id="12-互联网概述"><a class="markdownIt-Anchor" href="#12-互联网概述"></a> 1.2 互联网概述</h2>
<ol>
<li>计算机网络由若干节点(node)和连接这些节点的链路(link)组成</li>
<li>互联网是“<strong>网络的网络</strong>”(network of networks)</li>
<li>连接在因特网上的计算机都称为主机 (host)</li>
<li>互联网三个阶段：
<ul>
<li><strong>第一阶段</strong>：从单个网络ARPANET向互联网发展的过程，1983年TCP/IP协议成为ARPANET上的标准协议，<strong>人们把1983年作为因特网的诞生时间</strong>，特点：TCP/IP首次成型</li>
<li><strong>第二阶段</strong>：建立了三级结构的互联网，特点：分为主干网，地区网，校园网</li>
<li><strong>第三阶段</strong>：形成了多层次的ISP结构的互联网，ISP的首次出现</li>
</ul>
</li>
<li>小写开头的internet泛指多个计算机网络互连而成的网络，大写开头的Internet指代因特网，前身是ARPANET</li>
<li><strong>ISP</strong>(Internet Service Provider)划分成不同层次
<ul>
<li>主干ISP：服务面积大，覆盖国家</li>
<li>地区ISP：通过一个或多个主干ISP连接</li>
<li>本地ISP：给用户提供直接服务的ISP，也称末端用户，可以是公司，学院或者大学</li>
<li>三层ISP结构图：<img src="/2019/12/05/study/network/1.png" alt="三层ISP结构图" /></li>
</ul>
</li>
<li>互联网交换点<strong>IXP</strong>(Internet eXchange Point)：允许两个网络直连交换分组，不需要通过第三个网络来转发分组，这样可以更快的转发分组，有效利用网络资源</li>
<li>万维网 WWW (World Wide Web)</li>
</ol>
<h2 id="13-互联网的组成"><a class="markdownIt-Anchor" href="#13-互联网的组成"></a> 1.3 互联网的组成</h2>
<ol>
<li>以工作方式划分为两大块：
<ul>
<li><strong>边缘部分</strong>：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信(传送数据、音频或视频) 和资源共享。<strong>低速</strong>接入互联网。</li>
<li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)。<strong>高速</strong>进行分组交换。</li>
</ul>
</li>
<li>处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为<strong>端系统(end system)</strong>。<br />
“主机 A 和主机 B 进行通信”，实际上是指:“运行在主机 A 上的某个程序和 运行在主机 B 上的另一个程序进行通信”。<br />
即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信”</li>
<li>两种通讯方式：
<ul>
<li><strong>客户−服务器方式(C/S 方式)</strong>，Client/Server</li>
<li><strong>对等方式(P2P 方式)</strong>，Peer-to-Peer</li>
</ul>
</li>
<li><strong>客户-服务器方式C/S</strong>：都是指通信中所涉及的两个应用进程，所描述的是进程之间服务和被服务的关系。客户是服务的请求方，服务器是服务的提供方。</li>
<li><strong>客户软件的特点</strong>：被用户调用后运行，在打算通信时主动向远地服务器发起通信(请求服务)。因此，客户程序必须知道服务器程序的地址。不需要特殊的硬件和很复杂的操作系统。</li>
<li><strong>服务器软件的特点</strong>：一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。系统启动后即自动调用并<strong>一直不断地运行着，被动地等待</strong>并接受来自各地的客 户的通信请求。因此，服务器程序不需 要知道客户程序的地址。一般需要强大的硬件和高级的操作系统支持。</li>
<li><strong>对等连接方式P2P</strong>：指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件 (P2P 软件)，它们就可以进行<strong>平等的、 对等连接通信</strong>。双方都可以下载对方已经存储在硬盘中的共享文档。</li>
<li><strong>对等连接方式的特点</strong>：对等连接方式从本质上看仍然是使用客 户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。例如主机 C 请求 D 的服务时，C 是客户， D 是服务器。但如果 C 又同时向 F提供 服务，那么 C 又同时起着服务器的作用。</li>
<li>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信(即传送或接收各种形式的数据)。</li>
<li>在网络核心部分起特殊作用的是<strong>路由器(router)</strong>，路由器是实现<strong>分组交换</strong>(packet switching) 的关键构件，其任务是转发收到的分组，这是<strong>网络核心部分最重要的功能</strong>。</li>
<li><strong>电路交换</strong>：2部电话只需要1对电线，5部电话需要10对电线， N 部电话机两两相连，需 N(N – 1)/2 对电线。当电话机的数量很大时，这种连接方法需要的电线 对的数量与电话机数的平方成正比。</li>
<li>交换机交换（使用交换机进行电路交换）：“<strong>交换</strong>”(switching)的含义就是<strong>转接</strong>——把一条电话线转接到另一条电话线，使它们连通起来。从通信资源的分配角度来看，“交换” 就是按照某种方式<strong>动态地分配</strong>传输线路的资源。</li>
<li><strong>电路交换特点</strong>：
<ul>
<li>电路交换必定是面向连接的</li>
<li>电路交换的三个阶段：
<ul>
<li>建立连接</li>
<li>通信</li>
<li>释放连接</li>
</ul>
</li>
<li>电路交换传送计算机数据效率低</li>
<li>在电话通话的全部时间内，通话的两个用户始终占用端到端的通信资源</li>
</ul>
</li>
<li><strong>分组交换</strong>：采用<strong>存储转发</strong>技术，我们把要发送的整块数据称为一个<strong>报文</strong>(message)，在发送端，先把较长的报文划分成较短的、固定长度的<strong>数据段</strong>，每一个数据段前面添加上<strong>首部</strong>构成<strong>分组</strong>。分组又称为<strong>包</strong>，分组的首部也可以称为<strong>包头</strong>。</li>
<li>因特网的核心部分：
<ul>
<li>由许多<strong>网络</strong>和把它们互连起来的<strong>路由器</strong>组成，而<strong>主机处在因特网的边缘部分</strong>。</li>
<li>在因特网核心部分的路由器之间一般都用高速 链路相连接，而在网络边缘的主机接入到核心 部分则通常以相对较低速率的链路相连接。</li>
<li>主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的</li>
</ul>
</li>
<li>讨论互联网核心部分中的路由器转发分组的过程时，往往把单个网络简化成一条<strong>链路</strong>，而路由器成为核心部分的<strong>节点</strong>。</li>
<li>路由器：在路由器中的输入和输出端口之间没有直接连线。路由器处理分组的过程是：
<ul>
<li>把收到的分组先放入缓存（暂时存储）</li>
<li>查找转发表，找出到某个目的地址应从哪个端口转发</li>
<li>把分组送到适当的端口转发出去</li>
</ul>
</li>
<li><strong>主机和路由器的不同</strong>：
<ul>
<li><strong>主机</strong>是为用户进行<strong>信息处理</strong>的，并向网络发送分组，从网络接收分组。</li>
<li><strong>路由器</strong>对分组进行<strong>存储转发</strong>，实际就是<strong>分组交换</strong>，最后把分组交付目的主机</li>
</ul>
</li>
<li><strong>分组交换的优点</strong>：
<ul>
<li><strong>高效</strong>——动态分配传输带宽，对通信链路是逐段占用。</li>
<li><strong>灵活</strong>——以分组为传送单位和查找路由。</li>
<li><strong>迅速</strong>——不必先建立连接就能向其他主机发送分组。</li>
<li><strong>可靠</strong>——保证可靠性的网络协议。</li>
<li><strong>分布式</strong>——的路由选择协议使网络有很好的生存性。</li>
</ul>
</li>
<li><strong>分组交换带来的问题</strong>
<ul>
<li>分组在各结点存储转发时需要排队，这就会造成一定的<strong>时延</strong>。</li>
<li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的<strong>开销</strong>，还需要专门的管理和控制机制。</li>
</ul>
</li>
<li>三种交换方式在数据传送阶段的主要特点：
<ul>
<li>电路交换——整个报文的比特流连续地从源点直达终点，好像在一个管道中转发。</li>
<li>报文交换——整个报文先转发到相邻节点，全部存储下来后查找转发表，转发到下一个节点</li>
<li>分组交换——单个分组（这只是整个报文的一部分）传送到相邻节点，存储下来后查找转发表，转发到下一个节点</li>
<li><img src="/2019/12/05/study/network/2.png" alt="三种交换的比较" /></li>
<li>由于一个分组的长度往往远小于整个报文长度，因此分组交换比报文交换的时延小，同时也具有更好的灵活性</li>
</ul>
</li>
<li>传统的电路交换(circuit switching)的电信网有一个缺点：正在通信的电路中有一个交换机或有一条链路被炸毁，则整个通信电路就要中断。如要改用其他迂回电路，必须重新拨号建立连接。这将要延误一些时间</li>
<li>新型网络的基本特点:
<ul>
<li>网络用于计算机之间的数据传送，而不是为了打电话。</li>
<li>网络能够连接不同类型的计算机，不局限于单一类型的计算机。</li>
<li>所有的网络结点都同等重要，因而大大提高网络的生存性。</li>
<li>计算机在进行通信时，必须有冗余的路由。</li>
<li>网络的结构应当尽可能地简单，同时还能够非常可靠地传送数据。</li>
</ul>
</li>
<li>早期的面向终端的计算机网络是以<strong>单个主机为中心</strong>的星形网.分组交换网则是以<strong>网络为中心</strong>，主机都处在网络的外围。</li>
</ol>
<h2 id="15-计算机网络的分类"><a class="markdownIt-Anchor" href="#15-计算机网络的分类"></a> 1.5 计算机网络的分类</h2>
<ol>
<li>不同的定义：
<ul>
<li>计算机网络是一些互相连接的、自治的计算机的集合。</li>
<li>因特网(Internet)是“网络的网络”。</li>
</ul>
</li>
<li>不同的网络分类：
<ol>
<li>网络的作用范围分类：
<ul>
<li>广域网 WAN (Wide Area Network)</li>
<li>局域网 LAN (Local Area Network)</li>
<li>城域网 MAN (Metropolitan Area Network)</li>
<li>个人区域网 PAN (Personal Area Network)</li>
</ul>
</li>
<li>网络的使用者分类：
<ul>
<li>公用网 (public network)</li>
<li>专用网 (private network)</li>
</ul>
</li>
<li>主干和接入网：
<ul>
<li>ISP，提供的接入网只是起到让用户能够与因特网连接的“桥梁”作用。</li>
<li>AN(Access Network)，它又称为本地接入网或居民接入网。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="16-计算机网络的性能"><a class="markdownIt-Anchor" href="#16-计算机网络的性能"></a> 1.6 计算机网络的性能</h2>
<h3 id="161-性能指标"><a class="markdownIt-Anchor" href="#161-性能指标"></a> 1.6.1 性能指标</h3>
<ol>
<li>速率：指的是<strong>数据的传送速率</strong>，也称为数据率。</li>
<li>带宽：原本指的是某个信号具有的频带宽带，计网中表达是的网络中某<strong>通道</strong>传送数据的能力，在单位时间内某信号所通过的“<strong>最高数据率</strong>”，这种意义下的<strong>单位是bit/s，比特每秒</strong>。前者是<strong>频域称</strong>谓，后者是<strong>时域</strong>称谓。</li>
<li>带宽：原本指的是某个信号具有的频带宽带，计网中表达是的网络中某<strong>通道</strong>传送数据的能力，在单位时间内某信号所通过的“<strong>最高数据率</strong>”，这种意义下的<strong>单位是bit/s，比特每秒</strong>。前者是<strong>频域称</strong>谓，后者是<strong>时域</strong>称谓。</li>
<li>吞吐量：单位时间内通过某个网络（或通道，端口）的实际数据量，吞吐量受到网络带宽或网络额定速率的限制。</li>
<li>时延：指数据（或一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，也称为延迟或迟延。
<ol>
<li>发送时延：从主机或路由器发送数据帧所需要的时间。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>发送时延</mtext><mo>=</mo><mfrac><mtext>数据帧长度(bit)</mtext><mtext>发送速率(bit/s)</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{发送时延}=\frac{\text{数据帧长度(bit)}}{\text{发送速率(bit/s)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">发送时延</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">发送速率</span><span class="mord mtight">(bit/s)</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">数据帧长度</span><span class="mord mtight">(bit)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>传播时延：电磁波在信道中传播一定的距离需要花费的时间。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>传播时延</mtext><mo>=</mo><mfrac><mtext>信道长度(m)</mtext><mtext>电磁波在信道上的传播速度(m/s)</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{传播时延}=\frac{\text{信道长度(m)}}{\text{电磁波在信道上的传播速度(m/s)}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">传播时延</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">电磁波在信道上的传播速度</span><span class="mord mtight">(m/s)</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">信道长度</span><span class="mord mtight">(m)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>处理时延：主机或路由器接受到分组之后需要时间进行处理。</li>
<li>排队时延：分组进过路由器时，需要进入缓存<strong>排队</strong>等待交换，出现排队时延，排队时延的长短往往取决于网络中<strong>当时的通信量</strong>。</li>
<li>总时延=发送时延+传播时延+处理时延+排队时延</li>
</ol>
</li>
<li>时延带宽积=传播时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span>带宽，又称为<strong>以比特为单位的链路长度</strong>。</li>
<li>往返时间RTT：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>有效数据率</mtext><mo>=</mo><mfrac><mtext>数据长度</mtext><mtext>发送时间+RTT</mtext></mfrac><mrow><mo fence="true">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">/</mi><mi>s</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{有效数据率}=\frac{\text{数据长度}}{\text{发送时间+RTT}}\left(bit/s\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">有效数据率</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.275662em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.872331em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">发送时间</span><span class="mord mtight">+RTT</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">数据长度</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></li>
<li>利用率：
<ul>
<li>信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)。完全空闲的信道的利用率是零。</li>
<li>网络利用率则是全网络的信道利用率的 加权平均值。信道利用率并非越高越好。</li>
<li>如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示空闲时时延，U表示网络利用率，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D=\frac{D_0}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2917619999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">U</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
</ol>
<h3 id="162-非性能特征"><a class="markdownIt-Anchor" href="#162-非性能特征"></a> 1.6.2 非性能特征</h3>
<ol>
<li>费用</li>
<li>质量</li>
<li>标准化</li>
<li>可靠性</li>
<li>可扩展性和升级性</li>
<li>易于管理和维护</li>
</ol>
<h2 id="17-计算机网络体系结构"><a class="markdownIt-Anchor" href="#17-计算机网络体系结构"></a> 1.7 计算机网络体系结构</h2>
<ol>
<li>相互通信的两个计算机系统必须<strong>高度协调</strong>工作才行，而这种“协调”是相当复 杂的。</li>
<li>“<strong>分层</strong>”可将庞大而复杂的问题，转化 为若干较小的局部问题，而这些较小的 局部问题就比较易于研究和处理。</li>
<li><strong>网络协议</strong>(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</li>
<li>网络协议的组成要素：
<ul>
<li>语法——数据与控制信息的结构或格式 。</li>
<li>语义——需要发出何种控制信息，完成何 种动作以及做出何种响应。</li>
<li>同步——事件实现顺序的详细说明。</li>
</ul>
</li>
<li>分层的好处：
<ul>
<li>各层之间是独立的。</li>
<li>灵活性好。</li>
<li>结构上可分割开。</li>
<li>易于实现和维护。</li>
<li>能促进标准化工作。</li>
</ul>
</li>
<li>层数多少要适当：若层数太少，就会使每一层的协议太复杂。层数太多又会在描述和综合各层功能的 系统工程任务时遇到较多的困难。</li>
<li>5层协议的体系结构：
<ul>
<li>应用层(application layer)</li>
<li>运输层(transport layer)</li>
<li>网络层(network layer)</li>
<li>数据链路层(data link layer)</li>
<li>物理层(physical layer)</li>
</ul>
</li>
<li>实体、协议、服务 和服务访问点：
<ul>
<li><strong>实体</strong>(entity)——表示任何可发送或接收信息的硬件或软件进程。</li>
<li>协议——控制<strong>两个对等实体</strong>进行通信的规则的集合。</li>
<li>在协议的控制下，两个对等实体间的通信使得本层能够<strong>向上一层提供服务</strong>。</li>
<li>要实现本层协议，还需要使用<strong>下层</strong>所提供的服务。</li>
<li>下面的协议对上面的服务用户是<strong>透明</strong>的。</li>
<li><strong>协议是“水平的”</strong>，即协议是控制对等实体之间通信的规则。</li>
<li><strong>服务是“垂直的”</strong>，即服务是由下层向上层通 过层间接口提供的。</li>
<li>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点 SAP</strong> (Service Access Point)</li>
</ul>
</li>
<li>协议必须把所有<strong>不利的条件</strong>事先都估计到，而<strong>不能假定</strong>一切都是正常的和非常理想的，必须非常仔细地检查这个协议<strong>能否应付各种异常情况</strong>。</li>
</ol>
<h1 id="第二章-物理层"><a class="markdownIt-Anchor" href="#第二章-物理层"></a> 第二章 物理层</h1>
<h2 id="21-物理层的概念"><a class="markdownIt-Anchor" href="#21-物理层的概念"></a> 2.1 物理层的概念</h2>
<ol>
<li>物理层的主要任务描述为确定与传输媒体的接口的一些特性，即:
<ul>
<li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li>
<li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li>
</ul>
</li>
</ol>
<h2 id="22-数据通道的基础知识"><a class="markdownIt-Anchor" href="#22-数据通道的基础知识"></a> 2.2 数据通道的基础知识</h2>
<ol>
<li>几个术语：
<ul>
<li><strong>数据</strong>(data)——运送消息的实体。</li>
<li><strong>信号</strong>(signal)——数据的电气的或电磁的表现。</li>
<li>“<strong>模拟的</strong>”(analogous)——代表消息的参数的取值是连续的。</li>
<li>“<strong>数字的</strong>”(digital)——代表消息的参数的取值是离散的。</li>
<li><strong>码元</strong>(code)——在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形。</li>
<li>模拟信号——连续的信号</li>
<li>数字信号——</li>
</ul>
</li>
<li>数据在通信线路上的传输方式一般都是<strong>串行</strong>传输。</li>
<li>一个数据通信系统可以划分三大部分：<strong>源系统</strong>（或发送端、发送方）、<strong>传输系统</strong>（或传输网络）和<strong>目的系统</strong>（或接收端、接收方）。输入信息–(源点)–&gt;输入数据–(发送器)–&gt;发送的信号–(传输系统)–&gt;接受的信号–(接收器)–&gt;输出数据–(终点)–&gt;输出信息。 <img src="/2019/12/05/study/network/3.png" alt="数据过程" /></li>
<li>源系统包含：源点、发送器</li>
<li>目的系统包含：接收器、终点</li>
<li>几个概念：
<ul>
<li><strong>单向通信(单工通信)</strong>——只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>双向交替通信(半双工通信)</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>双向同时通信(全双工通信)</strong>——通信的双方可以同时发送和接收信息。</li>
<li><strong>基带信号</strong>(即基本频带信号)——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>(modulation)。</li>
<li><strong>带通信号</strong>——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)。</li>
</ul>
</li>
<li>基带解调，编码，载波，带通信号，带通解调</li>
<li>最基本的二元制调制方法有以下几种：
<ul>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。</li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM) ：载波的初始相位随基带数字信号而变化。</li>
</ul>
</li>
<li>奈氏准则，在任何信道中，码元传输的速率是有上限的，否则就会出现<strong>码间串扰</strong>的问题，使接收端对码元的判决(即识别)成为不可能。</li>
<li>香农公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C=Wlog_2(1+S/N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">b/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>，W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率。用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的<strong>极限、无差错</strong>的信息传输速率。</li>
<li>信噪比(dB)=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>10</mn></msub><mo stretchy="false">(</mo><mi>S</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>d</mi><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">10log_{10}(S/N)(dB)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></li>
</ol>
<h2 id="23-物理层下面的传输媒体"><a class="markdownIt-Anchor" href="#23-物理层下面的传输媒体"></a> 2.3 物理层下面的传输媒体</h2>
<ol>
<li>导引型传输媒体：
<ul>
<li>双绞线：屏蔽双绞线，无屏蔽双绞线</li>
<li>同轴电缆：50<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>同轴电缆，75<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>同轴电缆</li>
<li>光缆：单模光纤，多模光纤</li>
</ul>
</li>
<li>非导引型传输媒体
<ul>
<li>短波</li>
<li>微波</li>
<li>卫星</li>
</ul>
</li>
</ol>
<h2 id="24-信道复用技术"><a class="markdownIt-Anchor" href="#24-信道复用技术"></a> 2.4 信道复用技术</h2>
<ol>
<li><strong>频分复用</strong>：所有用户在同样的时间占用不同的带宽（频率带宽）资源</li>
<li><strong>时分复用</strong>：将时间划分为一段段等长的<strong>时分复用帧</strong>(TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是<strong>周期性地出现</strong>(其周期就是 TDM 帧的长度)。TDM 信号也称为<strong>等时</strong>(isochronous)信号。时分复用的所有用户是在不同的时间占用<strong>同样</strong>的频带宽度。</li>
<li><strong>统计时分复用</strong></li>
<li><strong>波分复用</strong>：光的频分复用。</li>
<li><strong>码分复用CDM</strong>：常用的名词是<strong>码分多址 CDMA</strong>。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。每一个比特时间划分为 m 个短的间隔，称为<strong>码片</strong>(chip)。</li>
<li>码分复用：当码片序列长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> bit发送的信息的速率为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> bit/s，则实际的发送速率要达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">mb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span></span></span></span> bit/s</li>
<li>CDMA 的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相<strong>正交</strong>(orthogonal)。在实用的系统中是使用<strong>伪随机码序列</strong>。</li>
<li><strong>待补</strong></li>
</ol>
<h2 id="25-数字传输系统"><a class="markdownIt-Anchor" href="#25-数字传输系统"></a> 2.5 数字传输系统</h2>
<ol>
<li><strong>待补</strong></li>
</ol>
<h1 id="第三章-数据链路层"><a class="markdownIt-Anchor" href="#第三章-数据链路层"></a> 第三章 数据链路层</h1>
<ol>
<li>链路层使用的信道分为两种类型：
<ul>
<li>点对点信道——一对一</li>
<li>广播信道——一对多</li>
</ul>
</li>
</ol>
<h2 id="31-使用点对点信道的数据链路层"><a class="markdownIt-Anchor" href="#31-使用点对点信道的数据链路层"></a> 3.1 使用点对点信道的数据链路层</h2>
<ol>
<li><strong>链路</strong>(link)：是一条无源的点到点（一个节点到相邻节点）的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li>
<li><strong>数据链路</strong>(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。最常用的就是<strong>网络适配器</strong>（即网卡）。</li>
<li>数据链路层传送的是<strong>帧</strong>。</li>
<li>数据链路层的三个基本问题：<strong>封装成帧、透明传输和差错检测</strong>。</li>
<li>早期的数据通信协议曾叫作<strong>通信规程</strong> (procedure)。因此在数据链路层，规程和协议是同义语。</li>
<li><strong>封装成帧</strong>(framing)：就是在一段数据的前后分别 添加首部和尾部，然后就构成了一个帧。确定 帧的界限。首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li>
<li>每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限——最大传送单元 MTU</strong> (Maximum Transfer Unit)。</li>
<li>控制字符SOH(Start Of Header)放在一帧的最前面，EOT(End Of Transmission)放在一帧的结束。如果只有SOH没有EOT则丢弃。</li>
<li><strong>透明传输</strong>：如果在数据中发现非ASCII字符并且与SOH或EOT一致，那么会<strong>错误</strong>地“找到数据帧边界”。若发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”，则在前面插入一个转义字符 “ESC”(其十六进制编码是 1B)。</li>
<li><strong>字节填充</strong>(byte stuffing)或<strong>字符填充</strong>(character stuffing)——接收端的数据链路层在将数据送往网 络层之前删除插入的转义字符</li>
<li>透明传输的”透明“：指的是<strong>某一个实际存在的事物看起来却好像不存在一样</strong>。</li>
<li><strong>差错检测</strong>：在传输过程中可能会产生<strong>比特差错</strong>: 1可能会变成0而0也可能变成1。在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率 BER</strong> (Bit Error Rate)。误码率与信噪比有很大的关系。</li>
<li>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验 CRC</strong> 的检错技术。在发送端，先把数据划分为组。假定每组 k 个比特。n 假设待传送的一组数据 M = 101001(现在 k = 6)。我们在 M 的后面再添加供差错检测用的 n 位<strong>冗余码</strong>一起发送。</li>
<li><strong>循环冗余码的计算，待补</strong></li>
<li>在数据后面添加上的冗余码称为<strong>帧检验序列</strong> FCS</li>
<li>CRC 是一种常用的<strong>检错方法</strong>，而 FCS 是添加在数据后面的<strong>冗余码</strong>。</li>
<li>仅用循环冗余检验 CRC 差错检测技术只能做到无差错<strong>接受</strong>(accept)。“无差错接受”是指:“凡是接受的帧(即不<strong>包括丢弃的帧</strong>)，我们都能以非常接近于 1 的 概率认为这些帧在传输过程中没有产生差错”。也就是说:“凡是接收端数据链路层接受的帧 都没有传输差错”(有差错的帧就丢弃而不接 受)。要做到“<strong>可靠传输</strong>”(即发送什么就收到什么) 就必须再加上<strong>确认</strong>和<strong>重传</strong>机制。</li>
</ol>
<h2 id="32-点对点协议-ppp"><a class="markdownIt-Anchor" href="#32-点对点协议-ppp"></a> 3.2 点对点协议 PPP</h2>
<ol>
<li>现在全世界使用得最多的数据链路层协议是<strong>点对点协议 PPP</strong> (Point-to-Point Protocol)。</li>
<li>PPP 协议应满足的需求：
<ul>
<li>简单——这是<strong>首要的要求</strong>：互操作性提高了</li>
<li>封装成帧：必须规定特殊字符作为帧定界符</li>
<li>透明性</li>
<li>多种网络层协议：同一条物理链路上同时支持多种网络层协议</li>
<li>多种类型链路</li>
<li>差错检测：立刻丢弃有差错的帧</li>
<li>检测连接状态</li>
<li>最大传送单元：是数据链路层的帧可以负载的数据部分的最大长度，而不是帧的总长度</li>
<li>网络层地址协商</li>
<li>数据压缩协商</li>
</ul>
</li>
<li>PPP 协议不需要的功能:
<ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>多点线路</li>
<li>半双工或单工链路</li>
</ul>
</li>
<li>PPP 协议的组成：
<ul>
<li>一个将 IP 数据报封装到串行链路的方法。</li>
<li><strong>链路控制协议</strong> LCP (Link Control Protocol)。</li>
<li><strong>网络控制协议</strong> NCP (Network Control Protocol)。</li>
</ul>
</li>
<li>PPP 协议的帧格式:<br />
PPP 有一个 2 个字节的协议字段。<br />
当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。<br />
若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021，则表示这是网络控制数据。<br />
<img src="/2019/12/05/study/network/4.png" alt="PPP 协议的帧格式" /></li>
<li>PPP 协议的信息字段长度是可变的，但不超过<strong>1500字节</strong>。</li>
<li>PPP 透明传输问题：当 PPP 用在同步传输链路时，协议规定 采用硬件来完成比特填充(和 HDLC 的 做法一样)。当 PPP 用在异步传输时，就使用一种特殊的<strong>字符填充法</strong>：
<ul>
<li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。</li>
<li>若信息字段中出现一个 0x7D 的字节，则将其转变成为 2 字节序列(0x7D, 0x5D)。</li>
<li>若信息字段中出现 ASCII 码的控制字符 (即数值小于 0x20 的字符)，则在该字 符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li>
</ul>
</li>
<li>零比特填充：PPP 协议用在 SONET/SDH 链路时，是使用同步传输，这时 PPP 协议采用零比特填充方 法来实现透明传输。信息字段每出现5个连续的1，则添加一个0，这样不会产生控制字符F相同的信息部分。</li>
<li>PPP 协议之所以不使用序号和确认机制是出于以下的考虑：
<ul>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数 据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ul>
</li>
<li>PPP 协议的工作状态：暂无</li>
</ol>
<h2 id="33-使用广播信道的数据链路层"><a class="markdownIt-Anchor" href="#33-使用广播信道的数据链路层"></a> 3.3 使用广播信道的数据链路层</h2>
<ol>
<li></li>
</ol>
]]></content>
      <categories>
        <category>学科复习</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计网复习</tag>
      </tags>
  </entry>
  <entry>
    <title>XCPC退役总结</title>
    <url>/2021/05/31/xcpc/xcpc-ending/</url>
    <content><![CDATA[<h1 id="奖项列表"><a class="markdownIt-Anchor" href="#奖项列表"></a> 奖项列表</h1>
<p>在5月30日的下午，在北京CCPC Final的现场，我终于退役啦，结束了大学四年的XCPC生涯。<br />
先总结一下四年打过的比赛和奖项吧。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>日期</th>
<th>名称</th>
<th>奖项</th>
<th>队友</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2018/01</td>
<td>2017 浙江工商大学新生赛</td>
<td>第一</td>
<td></td>
<td>进入ZJGSU ACM实验室</td>
</tr>
<tr>
<td>2</td>
<td>2018/04</td>
<td>2018 浙江工商大学校赛</td>
<td>第四</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>2018/04</td>
<td>2018 浙江省大学生程序设计竞赛</td>
<td>铁牌</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>2018/06</td>
<td>2018 ICPC 上海邀请赛</td>
<td>铜牌</td>
<td>黄队，蛋神</td>
<td>第一次拿牌</td>
</tr>
<tr>
<td>5</td>
<td>2018/10</td>
<td>2018 ICPC 南京区域赛</td>
<td>铁牌</td>
<td>噗噗，老板</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>2019/04</td>
<td>2019 浙江工商大学校赛</td>
<td>第二</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>2019/04</td>
<td>2019 浙江省大学生程序设计竞赛</td>
<td>铜牌</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>2019/05</td>
<td>2019 CCPC 湘潭邀请赛</td>
<td>铜牌</td>
<td>缪少爷，龙神</td>
<td>全新组队</td>
</tr>
<tr>
<td>9</td>
<td>2019/06</td>
<td>2019 ICPC 南昌邀请赛</td>
<td>银牌</td>
<td>缪少爷，龙神</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>2019/09</td>
<td>2019 CCPC 秦皇岛区域赛</td>
<td>银牌</td>
<td>缪少爷，龙神</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>2019/11</td>
<td>2019 ICPC 南昌区域赛</td>
<td>银牌</td>
<td>缪少爷，龙神</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>2019/12</td>
<td>2019 ICPC EC-Final 西安</td>
<td>铁牌</td>
<td>缪少爷，龙神</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>2019/11</td>
<td>2019 CCPC Final 北京</td>
<td>铁牌</td>
<td>经理，噗噗</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>2020/10</td>
<td>2020 浙江省大学生程序设计竞赛</td>
<td>银牌</td>
<td>徐总，缪少爷</td>
<td>退役后重新再战</td>
</tr>
<tr>
<td>15</td>
<td>2020/11</td>
<td>2020 CCPC 威海区域赛</td>
<td>银牌</td>
<td>徐总，缪少爷</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>2021/04</td>
<td>2020 ICPC 昆明区域赛</td>
<td>银牌</td>
<td>徐总，缪少爷</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>2021/04</td>
<td>2020 ICPC EC-Final 西安</td>
<td>银牌</td>
<td>徐总，缪少爷</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>2021/05</td>
<td>2020 ICPC 银川区域赛</td>
<td>金牌</td>
<td>徐总，缪少爷</td>
<td>第一次金牌</td>
</tr>
<tr>
<td>19</td>
<td>2021/06</td>
<td>2020 CCPC Final 北京</td>
<td>铁牌</td>
<td>徐总，缪少爷</td>
<td>退役之战</td>
</tr>
</tbody>
</table>
<h1 id="组队过程"><a class="markdownIt-Anchor" href="#组队过程"></a> 组队过程</h1>
<p>除去非常规组队，一共经历3次组队。</p>
<p>第一次加入实验室后的第一个暑期集训，与室友和好朋友一起组了第一个队伍，最后打铁与南京站。</p>
<p>第二次加入实验室后的第二个暑期集训，与实验室的大佬缪少爷（保研浙大）和我的学弟龙神（安徽OI爷）。这期间一路从铜牌开始打到银牌，其实本来有希望在2020年上半年就获得第一个金牌，但可惜2020年疫情打破了一切计划。2020年初正值我ACM生涯巅峰时间，CF首次达到紫名，可惜疫情导致整个上半年赛季全部暂缓和取消，最终我和缪少爷进入了原地退役模式。</p>
<p>第三次在2020年9月，得知下半年赛站将以线上赛模式进行，比赛恢复常态化，当时我还在实习，和两位队友讨论后，决定再次组队，圆一下大学的梦，一直维持到毕业。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>这四年，我一共有3年半的时间付出在了ACM竞赛上，最终也算是没有遗憾的毕业了。这四年从来没有后悔过大一选择了ACM，或许说这个竞赛并不是适合所有人，但至少我在这个竞赛上得到了我想要的。</p>
<p>虽然曾一度想要靠ACM的奖项保研，但由于在2020年7月之前，没有得到那个梦寐以求的金牌，外加绩点排名没有其他人那么亮眼，所以我在申请了保研之后处于一种放弃的状态。2020年上半年退役后，有学长帮我内推了蚂蚁，我也是非常幸运的拿到了实习Offer。当时我没有Java基础，完全是在学长的鼓励下，抱着试试看的心态，几天时间突击了一波面经。最后在10月的时候通过了转正答辩，得到了我人生的第一份工作。</p>
<p>如果要说ACM给我带来了什么，那我的答案有几项内容：</p>
<ul>
<li>大学四年有了一项可以一直坚持下去事情，没有荒废这四年时光。</li>
<li>让我认识了一群努力的人，每年暑假只有两周，每年寒假都是坚持到封校，都在为了自己想要的在奋斗。</li>
<li>让我的付出成为了一个个奖牌，让我无数次跌倒，又能让我无数次在AC后呐喊，那种喜悦和成就感是可以一直去回忆的。</li>
</ul>
<p>虽然说弱校打ACM出不了成绩，但在那么多届学长的铺垫下，但至少我做到了，我的学弟们也都做到了。强校很多选手都是OI出身的，有着多年的算法竞赛经验，这是他们的绝对优势，但并不是真的无法追赶，无非是自己愿不愿意，能不能看得到希望罢了。希望ZJGSU ACM越来越好，希望实验室的柜子能有一天金牌多到放不下。</p>
<p>最后感谢 <strong>MS教练</strong> ，我们亲爱的老大！</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>2020年浙江工商大学新生赛</title>
    <url>/2020/12/20/xcpc/zjgsu/2020-acm-new/</url>
    <content><![CDATA[<h1 id="开篇"><a class="markdownIt-Anchor" href="#开篇"></a> 开篇</h1>
<p>首先很感谢各位新生们的参与</p>
<h1 id="题目难度"><a class="markdownIt-Anchor" href="#题目难度"></a> 题目难度</h1>
<p>题目列表</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center">Title</th>
<th style="text-align:center">Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">站神的 A+B problem</td>
<td style="text-align:center">3.84% (27/704)</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">站神与最简单的语言</td>
<td style="text-align:center">9.09% (1/11)</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">站神和一笔画圆</td>
<td style="text-align:center">9.11% (38/417)</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">站神打包快递</td>
<td style="text-align:center">3.33% (7/210)</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">站神的梦</td>
<td style="text-align:center">0.00% (0/12)</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">站神数颜色</td>
<td style="text-align:center">5.62% (9/160)</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">站神与肃正协议</td>
<td style="text-align:center">14.29% (79/553)</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">站神的演讲</td>
<td style="text-align:center">26.77% (106/396)</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">打破复读机</td>
<td style="text-align:center">26.84% (142/529)</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">吃米饭的站神</td>
<td style="text-align:center">24.31% (115/473)</td>
</tr>
</tbody>
</table>
<p>预计难度<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>&lt;</mo><mn>6</mn><mo>&lt;</mo><mn>7</mn><mo>&lt;</mo><mn>9</mn><mo>&lt;</mo><mn>0</mn><mo>&lt;</mo><mn>2</mn><mo>&lt;</mo><mn>5</mn><mo>&lt;</mo><mn>3</mn><mo>&lt;</mo><mn>1</mn><mo>&lt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">8 &lt; 6 &lt; 7 &lt; 9 &lt; 0 &lt; 2 &lt; 5 &lt; 3 &lt; 1 &lt; 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span><br />
实际过题排序<br />
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn><mo>&lt;</mo><mn>9</mn><mo>&lt;</mo><mn>7</mn><mo>&lt;</mo><mn>6</mn><mo>&lt;</mo><mn>2</mn><mo>&lt;</mo><mn>0</mn><mo>&lt;</mo><mn>5</mn><mo>&lt;</mo><mn>3</mn><mo>&lt;</mo><mn>1</mn><mo>&lt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">8 &lt; 9 &lt; 7 &lt; 6 &lt; 2 &lt; 0 &lt; 5 &lt; 3 &lt; 1 &lt; 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p>
<h1 id="评价"><a class="markdownIt-Anchor" href="#评价"></a> 评价</h1>
<p>今年难度比往年普遍大幅降低，原计划是3+3+3+1的难度区分，3个基础题，3个需要一些数学能力的题目，3个需要一些代码能力的题目，还有一道防AK题。但防AK题并不是刻意让你们做不出来的题，只不过考虑到选手的实力，会选择需要一定思考深度和能力要求的题目。</p>
<p>所以最后的过体量大致还是符合出题组预想的结果的，而且大部分选手都留到了最后，不知道参赛选手们的参赛体验如何，如果有更好的建议和批评都欢迎提出来呀</p>
<h1 id="题解链接们"><a class="markdownIt-Anchor" href="#题解链接们"></a> 题解链接们</h1>
<p><strong>括号内为题号</strong><br />
龙神的题解[2,3,5]：<a href="https://blog.csdn.net/panggeQAQ/article/details/111460746" target="_blank" rel="noopener">https://blog.csdn.net/panggeQAQ/article/details/111460746</a><br />
老会长的题解[1,6,9]：<a href="https://blog.csdn.net/m0_43448982/article/details/111460449" target="_blank" rel="noopener">https://blog.csdn.net/m0_43448982/article/details/111460449</a><br />
林大佬的题解[0,7,8]：<a href="https://blog.csdn.net/weixin_44282912/article/details/111460476" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44282912/article/details/111460476</a><br />
开心点的题解[4]: <a href="https://happier233.github.io/2020/12/20/contest/2019-ec-final/" target="_blank" rel="noopener">https://happier233.github.io/2020/12/20/contest/2019-ec-final/</a></p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>OJ</category>
        <category>ZJGSU</category>
      </categories>
      <tags>
        <tag>ZJGSU</tag>
        <tag>新生赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #469D</title>
    <url>/2019/11/13/xcpc/codeforces/950E/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://codeforces.com/contest/950/problem/D" target="_blank" rel="noopener">题目链接 - Codeforces #469D</a></p>
</blockquote>
<h2 id="题目简述"><a class="markdownIt-Anchor" href="#题目简述"></a> 题目简述：</h2>
<p>给出n个数据中心，把每天的时间分为h部分，每个数据中心有个更新时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><msub><mi>h</mi><mi>i</mi></msub><mo>≤</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_i(0\leq h_i \leq h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>。m个客户，每个客户的数据放在2个数据中心。<br />
现在要调整尽量少的数据中心，让这些数据中心时间向后调整一个小时。如果2个数据中心的时间一致，则会发生风险，不允许这种情况的发生，问至少调整几个数据中心，并且输出是哪些。</p>
<h2 id="题目思路"><a class="markdownIt-Anchor" href="#题目思路"></a> 题目思路：</h2>
<p>这题分析之后，如果一个客户关联的两个数据中心<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>u</mi></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>h</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">h_u+1=h_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则拉一条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mi mathvariant="normal">到</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">u到v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的边，如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>v</mi></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>h</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">h_v+1=h_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>则拉一条<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi mathvariant="normal">到</mi><mi>u</mi></mrow><annotation encoding="application/x-tex">v到u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault">u</span></span></span></span>的边，(如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>=</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">h_i+1=h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>视为0)。这样就产生了一个关联关系，每条边的源方向如果需要被选中，那么目的方向也必须被选中，图就建立起来了。<br />
然后对着这个图跑Tarjan。如果要选择在上层的强连通分量，那么下层的必须要选，答案将会变大，所以只选择最底部的强连通分量。然后只需要在最底部的强连通分量里面选择一个元素最少的强连通分量，将这个强连通分量输出即可。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巨菜的ACMer-Happier233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pw(x) (1ll &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bt(x, k) (((x) &gt;&gt; k) &amp; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(t, v, n) memset(t, v, sizeof(decltype(*(t))) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACM_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="keyword">int</span>(<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="keyword">int</span>(<span class="number">2e5</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m, h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[u] + <span class="number">1</span> == a[v] || a[u] + <span class="number">1</span> == a[v] + h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line">pii eg[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    eg[tot] = &#123;v, head[u]&#125;;</span><br><span class="line">    head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], st[N], belong[N], num[N];</span><br><span class="line"><span class="keyword">bool</span> inst[N];</span><br><span class="line"><span class="keyword">int</span> idx, top, scc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++idx;</span><br><span class="line">    st[top++] = u;</span><br><span class="line">    inst[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i != <span class="number">-1</span>; i = eg[i].second) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = eg[i].first;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inst[v]) &#123;</span><br><span class="line">            low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            v = st[--top];</span><br><span class="line">            inst[v] = <span class="literal">false</span>;</span><br><span class="line">            belong[v] = scc;</span><br><span class="line">            num[scc]++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (u != v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fill_n(dfn, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    fill_n(num, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    fill_n(inst, n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    idx = top = scc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            tarjan(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        fill_n(head, n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        rep(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            <span class="keyword">if</span> (check(u, v)) &#123;</span><br><span class="line">                addEdge(u, v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check(v, u)) &#123;</span><br><span class="line">                addEdge(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        work();</span><br><span class="line">        fill_n(g, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = eg[i].second) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = eg[i].first;</span><br><span class="line">                <span class="keyword">if</span> (belong[u] == belong[v])<span class="keyword">continue</span>;</span><br><span class="line">                g[belong[u]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mn = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= scc; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (mn == <span class="number">-1</span> || num[i] &lt; num[mn]) &#123;</span><br><span class="line">                mn = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[mn] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (belong[i] == mn) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" \n"</span>[++c == num[n]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./data/std.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("./data/std.out", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        solve();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end = clock();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Run Time: "</span> &lt;&lt; <span class="keyword">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>2019ICPC区域赛南昌站</title>
    <url>/2019/11/01/xcpc/contest/2019-icpc-region-NanChang/</url>
    <content><![CDATA[<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>肥宅很快乐这次差点就改名肥宅带伤上场(玩笑话)</p>
<p>这次比赛一开始三题还是非常顺利的，一路过关斩将1A。<br />
遇到G题之后开始犯了难。<br />
一度因为队友读错题和自己因为判无解wa4，然后怀疑题意读错开始重读题目。理解正确题意之后又wa2，忘记原因了。最后又发生了一发RE，然后可能用了太多的stl库，不知道RE的点在哪里，决定换一种稳妥的写法，最后AC，一共7次罚时。<br />
B题队友觉得暴力可解，但我一度怀疑人生，这时候理解错队友说的题意，写了一份无效代码，心态有点崩，这点需要调整。在调整了一会儿心态之后，估算了一波暴力复杂度在3^n，加上剪枝本地测试之后稳过，选择提交，1A。</p>
<p>整个过程还是比较平稳的，但5题就算没有那么高的罚时也进不了金牌区，要拿到金牌还得提高自己水平并且让自己的做题速度再有一个提升。</p>
<h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1>
<h2 id="b"><a class="markdownIt-Anchor" href="#b"></a> B</h2>
<p>题意说明保证输入的图是个二分图，只存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≤</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \leq j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)的边，并且每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>的出度不超过3，也就是最多3n条边。<br />
暴力枚举右边每个点选择的左边的点，每次选择一个点之后位运算屏蔽掉不能和他出现在同一个图里面的点。如果发生某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>找不到能选择的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，那么退出。<br />
动态维护每个点的当前权值和总和，如果超过之前的答案则剪枝退出。复杂度上限大约在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>3</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，剪枝优化之后本地随便测了几个极端数据耗时不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mi>s</mi></mrow><annotation encoding="application/x-tex">10^{-3}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">s</span></span></span></span>。</p>
<h2 id="g"><a class="markdownIt-Anchor" href="#g"></a> G</h2>
<p>给出一个1~n的全排列a，代表了一个序列b，还给出了一个MOD数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>M</mi><mi>O</mi><mi>D</mi></mrow><annotation encoding="application/x-tex">b_i=(a_i!)\%MOD</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">!</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span>。求b的最短子区间和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span>查询的x，保证x的范围不超过模数，但这个模数是一个合数，最大质因子是2803，也就是超过2803的阶乘对MOD取模后都为0，所以一共只有2803个非0数字，对着这2803个数字<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>求出所有答案，并且维护数组，得到长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">len_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的时候能得到的最大区间和。这个数组必定是非递减的，然后每次直接在数组内二分答案即可。</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>比赛</category>
        <category>2019</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>南昌</tag>
        <tag>ICPC区域赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 ICPC EC Final</title>
    <url>/2020/12/20/xcpc/contest/2019-ec-final/</url>
    <content><![CDATA[<h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1>
<h2 id="m"><a class="markdownIt-Anchor" href="#m"></a> M</h2>
<p><a href="https://ac.nowcoder.com/acm/contest/3732/M" target="_blank" rel="noopener">牛客题目链接</a></p>
<h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3>
<p>Pang believes that one cannot make an omelet without breaking eggs.</p>
<p>For a subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{1,2,\ldots,n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">}</span></span></span></span>, we calculate the score of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> as follows:</p>
<ol>
<li>Initialize the score as {0}0.</li>
<li>For any <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">i \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, add <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> to the score.</li>
<li>For any pair of integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> satisfying <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">j \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">i \in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>, if there exists positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \gt 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mi>k</mi></msup><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i^k=j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>, subtract <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> from the score.</li>
</ol>
<p>Find the maximum possible score over the choice of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>.</p>
<h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3>
<p>我任意选择一个子集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，只考虑条件2，可以得到的分值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>A</mi></mrow></msub><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i\in{A}}{a_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.07708em;vertical-align:-0.32708000000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999992em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32708000000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span><br />
如果需要扣除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的得分，必定存在某个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mi>k</mi></msup><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i^k=j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><br />
那么就可以反过来思考，我枚举所有的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">i^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k \ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mi>k</mi></msup><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i^k \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.985078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，例如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>16</mn><mo separator="true">,</mo><mn>32</mn><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{2,4,8,16,32,\ldots\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>3</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>91</mn><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{3,9,27,91,\ldots\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>5</mn><mo separator="true">,</mo><mn>25</mn><mo separator="true">,</mo><mn>125</mn><mo separator="true">,</mo><mn>625</mn><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{5,25,125,625,\ldots\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">2</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>6</mn><mo separator="true">,</mo><mn>36</mn><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{6,36,\ldots\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>…</mo></mrow><annotation encoding="application/x-tex">\ldots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span></li>
</ul>
<p>对于以上每个集合，分别考虑里面的数字选与不选，比如第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的集合，当我没有选择2但选择了4的时候，所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>j</mi><mo>∈</mo><mi>A</mi><mo>&amp;</mo><mi>j</mi><mo>=</mo><msup><mn>4</mn><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">b_j(j \in A \And j=4^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">&amp;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>都需要扣除，那么对于单个集合计算的复杂度就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>i</mi></msub><mi>n</mi><mo>×</mo><msup><mn>2</mn><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>i</mi></msub><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\log_{i}{n} \times 2^{\log_{i}{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20521714285714282em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>，那么总体复杂度的上界就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mi>i</mi><mi>n</mi></msubsup><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>i</mi></msub><mi>n</mi><mo>×</mo><msup><mn>2</mn><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>i</mi></msub><mi>n</mi></mrow></msup></mrow></mrow><annotation encoding="application/x-tex">\sum_i^n{\log_{i}{n} \times 2^{\log_{i}{n}}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148818em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.21752399999999997em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20521714285714282em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></span>，用起算器算一下当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">n=100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>的时候，上界不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2000000</mn></mrow><annotation encoding="application/x-tex">2000000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>的</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巨菜的ACMer-Happier233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pw(x) (1ll &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bt(x, k) (((x) &gt;&gt; k) &amp; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(t, v, n) memset(t, v, sizeof(decltype(*(t))) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (not defined(ACM_LOCAL) || defined(ACM_TEST))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">// a表示题目输入的a,b，b来存放当前i的i^k的所有数字的a,b组合</span></span><br><span class="line">pii a[N], b[N];</span><br><span class="line"><span class="comment">// c表示当前枚举集合的第j个=数字要选的时候需要被减去几次</span></span><br><span class="line"><span class="keyword">int</span> c[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 表示当前i是否被访问过，比如需要跳过4,8,9之类的数字</span></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll rst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, ll w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; m) &#123;</span><br><span class="line">        rst = max(rst, w);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(k + <span class="number">1</span>, w);</span><br><span class="line">    w += b[k].first;</span><br><span class="line">    w -= <span class="number">1l</span>l * b[k].second * c[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i += k) &#123;</span><br><span class="line">        c[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(k + <span class="number">1</span>, w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i += k) &#123;</span><br><span class="line">        c[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i].first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i].second;</span><br><span class="line"></span><br><span class="line">        ll ans = a[<span class="number">1</span>].first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll k = i; k &lt;= n; k *= i) &#123;</span><br><span class="line">                vis[k] = <span class="literal">true</span>;</span><br><span class="line">                b[++m] = a[k];</span><br><span class="line">            &#125;</span><br><span class="line">            rst = <span class="number">0</span>;</span><br><span class="line">            dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            ans += rst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./data/std.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//    freopen("./data/std.out", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (not defined(ACM_LOCAL) || defined(ACM_TEST))</span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        solve();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">clock_t</span> end = clock();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Run Time: "</span> &lt;&lt; <span class="keyword">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>XCPC</category>
        <category>OJ</category>
        <category>爆搜</category>
        <category>牛客</category>
      </categories>
      <tags>
        <tag>ec-final</tag>
        <tag>爆搜</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 CCPC-Final</title>
    <url>/2019/11/11/xcpc/contest/2019-ccpc-final/</url>
    <content><![CDATA[<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>这场比赛看到参赛队伍名单的时候就感觉是神仙云集，亚历山大，北京并没有想象的那么冷，中国传媒大学还是很大很厉害的。<br />
热身赛的时候vscode的cpp扩展貌似因为权限问题没有跑起来，正赛的时候也没时间去尝试怎么调教vscode了，但vscode写代码还是可以的，写完丢codeblock跑。<br />
正赛开始的签到题队友签了半小时没有调处来，然后我上去写，开了12个大小的数组，但因为少写一个&quot;dec&quot;，wa1，然后因为没仔细看题，所以是最后额外读了一个，等于读入了n+1个，最后应该<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">i \in [0,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>但写了一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i \in [0,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>少了个等号又wa1，最后用时一小时AC加两次罚时。<br />
构造题我们面向题面整了3个小时，没有整出来(内心OS: 出题人太坏坏了)。最后发现这个构造的确有点简单，就是个printf题，我只是一个没有思想的菜鸡啊。<br />
这场是我今年第一次打铁，感受到了去年南京的感觉，希望接下来的EC能有机会上场吧。</p>
<h1 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h1>
<p>暂无，待补</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>比赛</category>
        <category>2019</category>
        <category>CCPC</category>
      </categories>
      <tags>
        <tag>2019</tag>
        <tag>北京</tag>
        <tag>CCPC总决赛</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-5274 Dylans loves tree(树剖模板题)</title>
    <url>/2019/11/06/xcpc/hdu/5274/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5274" target="_blank" rel="noopener">题目链接 - HDU 5274</a></p>
</blockquote>
<h2 id="题目简述"><a class="markdownIt-Anchor" href="#题目简述"></a> 题目简述：</h2>
<p>一棵树有n个节点，每次修改其中一个节点的权值，或者查询从u到v的路径上所有的节点里面是否有出现奇数个的权值<br />
例如：一个路径上出现了 2 2 4 5 5，那答案就是4，题目保证每次查询路径上只有一个点出现奇数次。</p>
<h2 id="题目思路"><a class="markdownIt-Anchor" href="#题目思路"></a> 题目思路：</h2>
<p>这就是一个树上的节点修改，非常简单的树剖模板题。因为题目保证只有一个点出现奇数次，所以用树状数组维护异或和即可。当一个数字出现偶数次，异或和就会重新变为0。<strong>但这题有个坑点，a[i]∈N，N为自然数</strong>，所以有可能权值为0。所以在树状数组里维护权值+1的异或和即可，每次输出答案-1，这样当没有答案的时候正好可以输出-1。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巨菜的ACMer-Happier233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pw(x) (1ll &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;(x))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foreg(i, s, eg) for(int i = (s); ~i; i = (eg)[i].nxt)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> ll MOD = ll(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> e, nxt;</span><br><span class="line">    ll v;</span><br><span class="line"></span><br><span class="line">    Edge() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    Edge(<span class="keyword">int</span> a, ll b, <span class="keyword">int</span> c = <span class="number">0</span>) : e(a), v(b), nxt(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Edge &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (a.v == v ? e &lt; a.e : v &lt; a.v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll INF = ll(<span class="number">1e11</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="keyword">int</span>(<span class="number">2e5</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="keyword">int</span>(<span class="number">6e5</span> + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    Edge eg[M];</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ++n);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll v)</span> </span>&#123;</span><br><span class="line">        eg[cnt] = Edge(y, v, head[x]);</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">begin</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> Edge &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">return</span> eg[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> eg[i].nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; gh;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeChain</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> top[N]; <span class="comment">// 链条顶端点ID</span></span><br><span class="line">    <span class="keyword">int</span> fa[N]; <span class="comment">// 父亲节点</span></span><br><span class="line">    <span class="keyword">int</span> son[N]; <span class="comment">// 重儿子</span></span><br><span class="line">    <span class="keyword">int</span> deep[N]; <span class="comment">// 深度</span></span><br><span class="line">    <span class="keyword">int</span> num[N]; <span class="comment">// 儿子节点数（包括自己）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p[N]; <span class="comment">// 点在线段树中的ID</span></span><br><span class="line">    <span class="keyword">int</span> fp[N]; <span class="comment">// 线段树中ID对应的点</span></span><br><span class="line">    <span class="keyword">int</span> fe[N]; <span class="comment">// 每个点到父亲节点的边ID</span></span><br><span class="line">    <span class="keyword">int</span> ep[N]; <span class="comment">// 每个点到父节点对应的边在线段树中的ID</span></span><br><span class="line">    <span class="comment">// int fep[N]; // 线段树中ID对应的边</span></span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> pre, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        num[u] = <span class="number">1</span>;</span><br><span class="line">        deep[u] = d;</span><br><span class="line">        fa[u] = pre;</span><br><span class="line">        son[u] = <span class="number">-1</span>;</span><br><span class="line">        fe[u] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = gh.eg[i].e;</span><br><span class="line">            <span class="keyword">if</span> (v == pre) &#123;</span><br><span class="line">                fe[u] = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(v, u, d + <span class="number">1</span>);</span><br><span class="line">            num[u] += num[v];</span><br><span class="line">            <span class="keyword">if</span> (son[u] == <span class="number">-1</span> || num[v] &gt; num[son[u]]) &#123;</span><br><span class="line">                son[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getpos</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sp)</span> </span>&#123;</span><br><span class="line">        top[u] = sp;</span><br><span class="line">        p[u] = tot++;</span><br><span class="line">        fp[p[u]] = u;</span><br><span class="line">        ep[fe[u] &gt;&gt; <span class="number">1</span>] = p[u];</span><br><span class="line">        <span class="keyword">if</span> (son[u] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        getpos(son[u], sp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = gh.eg[i].e;</span><br><span class="line">            <span class="keyword">if</span> (v == son[u] || v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">            getpos(v, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        tot = start; <span class="comment">// start是线段树中的ID起始数值</span></span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        getpos(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; treec;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BITree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    ll c[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> _n)</span> </span>&#123;</span><br><span class="line">        n = _n;</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(ll) * ++n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> pos, ll v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; n; i += i &amp; (-i))</span><br><span class="line">            c[i] ^= v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; (-i))</span><br><span class="line">            ans ^= c[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; l) swap(l, r);</span><br><span class="line">        <span class="keyword">return</span> query(r) ^ query(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f1 = treec.top[u];</span><br><span class="line">    <span class="keyword">int</span> f2 = treec.top[v];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (f1 != f2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (treec.deep[f1] &lt; treec.deep[f2]) &#123;</span><br><span class="line">            swap(f1, f2);</span><br><span class="line">            swap(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        ans ^= tree.query(treec.p[f1], treec.p[u]);</span><br><span class="line">        u = treec.fa[f1];</span><br><span class="line">        f1 = treec.top[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (treec.deep[u] &gt; treec.deep[v]) &#123;</span><br><span class="line">        swap(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    ans ^= tree.query(treec.p[u], treec.p[v]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    m = n - <span class="number">1</span>;</span><br><span class="line">    gh.init(n);</span><br><span class="line">    tree.init(n);</span><br><span class="line">    rep(i, <span class="number">0</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        gh.addEdge(a, b, <span class="number">0</span>);</span><br><span class="line">        gh.addEdge(b, a, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; val[i + <span class="number">1</span>];</span><br><span class="line">        val[i + <span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    treec.build(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">0</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = treec.p[i + <span class="number">1</span>];</span><br><span class="line">        tree.change(p, val[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">0</span>, q) &#123;</span><br><span class="line">        <span class="keyword">int</span> c, x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) &#123;</span><br><span class="line">            ll ans = query(x, y);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (ans - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tree.change(x, val[x]);</span><br><span class="line">            tree.change(x, val[x] = y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./data/std.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("./data/std.out", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>XCPC</category>
        <category>OJ</category>
        <category>树剖</category>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>hdu</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title>计蒜客-39277 And And And(2019西安邀请赛-点分治)</title>
    <url>/2019/11/08/xcpc/jsk/39277/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://nanti.jisuanke.com/t/39277" target="_blank" rel="noopener">题目链接 - 计蒜客 39277</a></p>
</blockquote>
<h2 id="题目简述"><a class="markdownIt-Anchor" href="#题目简述"></a> 题目简述：</h2>
<p>给出一颗有n个节点的树，第2~n的父亲和边权<br />
求树上任意两点u,v (u &lt; v)的路径上的子集中的两点间的疑惑和为0的个数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><munderover><mo>∑</mo><mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><munder><mo>∑</mo><mrow><msup><mi>u</mi><mo mathvariant="normal">′</mo></msup><mo>⊆</mo><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow></munder><mrow><munderover><mo>∑</mo><mrow><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo>⊆</mo><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow></mrow><mi>n</mi></munderover><mrow><mo stretchy="false">[</mo><mi>u</mi><mo>&lt;</mo><mi>v</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><msup><mi>u</mi><mo mathvariant="normal">′</mo></msup><mo>&lt;</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">(</mo><msup><mi>u</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mo stretchy="false">]</mo></mrow></mrow></mrow></mrow></mrow><annotation encoding="application/x-tex">\sum_{u=1}^n{
    \sum_{v=1}^n{
        \sum_{u&#x27;\subseteq{E(u,v)}}{
            \sum_{v&#x27;\subseteq{E(u,v)}}^n{
                [u&lt;v][u&#x27;&lt;v&#x27;][X(u&#x27;,v&#x27;)=0]
            }
        }
    }
}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.167402000000001em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">⊆</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.8089950000000001em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mrel mtight">⊆</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span></span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5160049999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></span></span></span></span></span></p>
<p>E(u, v)是从u到v路径上的所有点，X(u, v)是u到v路径上所有的边权异或和</p>
<h2 id="题目思路"><a class="markdownIt-Anchor" href="#题目思路"></a> 题目思路：</h2>
<p>这样每次在确定根之后，可以把边权转换为点权，根节点的权值为0。转化完之后就可以用树分治解决这个问题。</p>
<p>每次找到一个合法的X(u,v)=0之后，以v作为根的视角去看u的子树大小作为sons[u]，再以u作为根的视角去看v的子树大小作为sons[v]，那么(u,v)这条合法路径对答案的贡献就是sons[u]*sons[v]</p>
<p>计算答案的时候需要特殊处理直接到达根节点的所有边的情况，假设u为根，v为子节点。</p>
<p>因为每次根不同，所以不知道以x作为树根，y作为子节点的时候，y子树的大小，所以预处理这颗树，算出每个(u,v)边对应的v子树的大小，每次计算答案的时候可以很方便的转化每个子树大小。</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 巨菜的ACMer-Happier233</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> ui;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pw(x) (1ll &lt;&lt; (x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bt(x, k) (((x) &gt;&gt; k) &amp; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sz(x) ((int)(x).size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, l, r) for(int i=(l);i&lt;(r);++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, l, r) for(int i=(r)-1;i&gt;=(l);--i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mst(t, v, n) memset(t, v, sizeof(decltype(*(t))) * (n))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACM_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="keyword">int</span>(<span class="number">1e5</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Grahp</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    Edge eg[M];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * ++n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span> </span>&#123;</span><br><span class="line">        eg[tot] = &#123;v, head[u], w&#125;;</span><br><span class="line">        head[u] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; gh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="comment">// q队列, fa祖先, sz是子树大小, smx是子树最大</span></span><br><span class="line"><span class="keyword">int</span> q[N], fa[N], sz[N], smx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">froot</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, mn = N, rt = <span class="number">0</span>;</span><br><span class="line">    q[l = r = <span class="number">1</span>] = s;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        smx[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = gh.eg[i].to;</span><br><span class="line">            <span class="keyword">if</span> (v == fa[u] || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            q[++r] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反向遍历所有点算size</span></span><br><span class="line">    <span class="keyword">while</span> (--l) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[l];</span><br><span class="line">        <span class="keyword">int</span> mx = max(smx[u], r - sz[u]);</span><br><span class="line">        <span class="keyword">if</span> (mx &lt; mn) mn = mx, rt = u;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 根节点没有fa</span></span><br><span class="line">        sz[fa[u]] += sz[u];</span><br><span class="line">        smx[fa[u]] = max(smx[fa[u]], sz[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sons子树方向节点个数, val根到该节点异或和, gc边后继方向的节点个数</span></span><br><span class="line"><span class="keyword">int</span> sons[N], gc[M];</span><br><span class="line">ll val[N];</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="keyword">int</span>(<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">ll nums[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">    fa[s] = rt;</span><br><span class="line">    val[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="comment">// 不计算s</span></span><br><span class="line">    q[l = r = <span class="number">0</span>] = s;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[l++];</span><br><span class="line">        nums[m++] = val[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = gh.eg[i].to;</span><br><span class="line">            <span class="keyword">if</span> (v == fa[u] || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            fa[v] = u;</span><br><span class="line">            q[++r] = v;</span><br><span class="line">            val[v] = val[u] ^ gh.eg[i].w;</span><br><span class="line">            <span class="comment">// 这个点方向后面有多少点</span></span><br><span class="line">            sons[v] = gc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nums, nums + m);</span><br><span class="line">    m = unique(nums, nums + m) - nums;</span><br><span class="line">    mst(cnt, <span class="number">0</span>, m);</span><br><span class="line">    <span class="comment">// 遍历分支</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = gh.head[s]; ~j; j = gh.eg[j].nxt) &#123;</span><br><span class="line">        <span class="comment">// 分支的根</span></span><br><span class="line">        <span class="keyword">int</span> du = gh.eg[j].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[du]) <span class="keyword">continue</span>;</span><br><span class="line">        q[l = r = <span class="number">1</span>] = du;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[l++];</span><br><span class="line">            <span class="keyword">int</span> k = lower_bound(nums, nums + m, val[u]) - nums;</span><br><span class="line">            (ans += <span class="number">1l</span>l * sons[u] * cnt[k] % MOD) %= MOD;</span><br><span class="line">            <span class="keyword">if</span> (val[u] == <span class="number">0</span>) &#123;</span><br><span class="line">                (ans += <span class="number">1l</span>l * sons[u] * (n - gc[j]) % MOD) %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = gh.eg[i].to;</span><br><span class="line">                <span class="keyword">if</span> (v == fa[u] || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">                q[++r] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加这个方向的值</span></span><br><span class="line">        <span class="keyword">while</span> (--l) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q[l];</span><br><span class="line">            <span class="keyword">int</span> k = lower_bound(nums, nums + m, val[u]) - nums;</span><br><span class="line">            (cnt[k] += sons[u]) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 换根</span></span><br><span class="line">    u = froot(u);</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    go(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gh.eg[i].to;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        work(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理边后继节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pdfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fg_id = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = gh.head[u]; ~i; i = gh.eg[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gh.eg[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v == f) &#123; <span class="comment">// 记录父边ID</span></span><br><span class="line">            fg_id = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> c = pdfs(v, u);</span><br><span class="line">        gc[i] = c;</span><br><span class="line">        s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在父边</span></span><br><span class="line">    <span class="keyword">if</span> (~fg_id) gc[fg_id] = n - s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        gh.init(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            ll w;</span><br><span class="line">            u = i;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            gh.addEdge(u, v, w);</span><br><span class="line">            gh.addEdge(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line">        mst(vis, <span class="literal">false</span>, n + <span class="number">1</span>);</span><br><span class="line">        pdfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        work(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./data/std.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("./data/std.out", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        solve();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">clock_t</span> end = clock();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Run Time: "</span> &lt;&lt; <span class="keyword">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>XCPC</category>
        <category>OJ</category>
        <category>树分治</category>
        <category>点分治</category>
        <category>计蒜客</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>计蒜客</tag>
        <tag>2019西安邀请赛</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM题优化经验</title>
    <url>/2021/07/25/xcpc/xcpc-optimize/</url>
    <content><![CDATA[<h1 id="为什么要优化"><a class="markdownIt-Anchor" href="#为什么要优化"></a> 为什么要优化</h1>
<p>如果一个算法的复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> ，那么实际耗时往往是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mo>×</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=k \times f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 就是代码的常数，但常数过大的时候就有可能超时。有些出题人会有意无意地卡常数，这时候不会代码优化技巧，则有可能被卡常错失AC。另外有可能因为对底层机制的了解不够，而踩坑，导致非常数因素的大幅耗时，最终TLE。</p>
<p>有些出题人对算法是有要求的，那么有可能会刻意卡掉一些空间需求高的算法，那么需要学会计算内存空间和空间优化。</p>
<h1 id="时间优化技巧"><a class="markdownIt-Anchor" href="#时间优化技巧"></a> 时间优化技巧</h1>
<h2 id="io优化"><a class="markdownIt-Anchor" href="#io优化"></a> IO优化</h2>
<p>从最基本的算法无关的优化点开始，IO优化。在输入输出的时候，底层都是会涉及IO，那么有IO操作的地方，必定有IO耗时，这个是操作系统的知识，这里不展开。</p>
<p>如果全代码都只用到了scanf, printf, gets, putchar这一系列的C语言函数，则不需要考虑IO优化。</p>
<p>如果使用到了C++的cin/cout，则有几个点需要注意。</p>
<ol>
<li>在输入或输出上不可以将C和C++的IO库混用。例如：在输入上不可scanf, getchar 和 cin 混用；在输出上不可printf 和 cout 混用；但 scanf 和 cout 是可以混用的。</li>
<li>若使用到了C++的IO库，则需要在代码中添加以下3行代码。但由于添加这3行代码后，输出结果不会立刻出现在控制台，会导致本地调试的时候困难，所以推荐在本地编译的时候增加宏定义，来区分是否是本地环境。<strong>切记这个宏定义不可和OJ添加的宏定义重名。</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>); <span class="comment">// 关闭c和c++的同步流</span></span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="comment">// 关闭cin的缓存流绑定</span></span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="number">0</span>); <span class="comment">// 关闭cout的缓存流绑定</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    freopen(<span class="string">"./data/std.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="comment">// freopen("./data/std.out", "w", stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> start = clock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//    cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        solve();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ACM_LOCAL</span></span><br><span class="line">    <span class="keyword">auto</span> end = clock();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Run Time: "</span> &lt;&lt; <span class="keyword">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">"s"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>由于C++的<code>endl</code>包含了<code>flush</code>，会导致输出流刷新。但由于内部机制，会使得输入流也发生同步行为，会导致IO耗时暴增，所以可以参考第二条，在非本地情况下将<code>endl</code>通过宏定义的方式，替换成 <code>'\n'</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACM_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>完整代码基础样板可以参考 <a href="https://github.com/happier233/ACM-Code/blob/master/00_%E5%A4%B4%E6%96%87%E4%BB%B6/00_Header.cpp" target="_blank" rel="noopener">https://github.com/happier233/ACM-Code/blob/master/00_头文件/00_Header.cpp</a></p>
<p>不建议在平时做题的时候经常使用快读模板，会养成坏习惯，在现场赛的时候往往没有时间去敲一份快读模板。正常情况下出题人不会硬卡IO的耗时，所以如果用快读模板过了题，但有可能去除快读还是会TLE，这说明你的算法没有达到正确的耗时要求。</p>
<p><strong>在开启IO优化的情况下，可以完全保证C++的cin, cout耗时和C的scanf, printf的耗时持平。</strong></p>
<h2 id="内存访问优化"><a class="markdownIt-Anchor" href="#内存访问优化"></a> 内存访问优化</h2>
<h2 id="小技巧"><a class="markdownIt-Anchor" href="#小技巧"></a> 小技巧</h2>
<p>这些小技巧优化有限，虽然不知道具体导致这些代码编译后的差异何在，但实测的确有效果，主要受到编译器优化影响。</p>
<h3 id="取模连写"><a class="markdownIt-Anchor" href="#取模连写"></a> 取模连写</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c, mod; <span class="comment">// 假设a, b, mod都已经有实际值，这里不写具体值</span></span><br><span class="line"></span><br><span class="line">a = a * b % mod; <span class="comment">// 基础写法</span></span><br><span class="line">(a *= b) %= mod; <span class="comment">// 技巧</span></span><br><span class="line"></span><br><span class="line">a = ((a * b) % mod) + c) % mod; <span class="comment">// 基础写法</span></span><br><span class="line">((a *= b) %= mod) += c) %= mod; <span class="comment">// 技巧</span></span><br></pre></td></tr></table></figure>
<h3 id="减少取模次数"><a class="markdownIt-Anchor" href="#减少取模次数"></a> 减少取模次数</h3>
<p>假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi><mo>=</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">mod=10^9+7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>, 有2个二维非负整数矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 大小， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">n, m \in [1, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，其中所有值都有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo separator="true">,</mo><msub><mi>b</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a_{ij}, b_{ij} \in [0, 10^4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，求 $ \sum_{i=1}^n ((\sum_{j=1}^m {a_{ij}}) \times (\sum_{j=1}^m {b_{ij}})) \bmod MOD $</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> ll MOD2 = <span class="number">1l</span>l * MOD * MOD;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sa = <span class="number">0</span>, sb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            (sa += a[i][j]) %= MOD;</span><br><span class="line">            (sb += a[i][j]) %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> si = (<span class="number">1l</span>l * sa * sb) % MOD;</span><br><span class="line">        (s += si) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次优化写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll sa = <span class="number">0</span>, sb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            sa += a[i][j];</span><br><span class="line">            sb += b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ll si = sa * sb;</span><br><span class="line">        (s += si) %= MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次优化写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc3</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll sa = <span class="number">0</span>, sb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            sa += a[i][j];</span><br><span class="line">            sb += b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ll si = sa * sb;</span><br><span class="line">        s += si;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= MOD2) s -= MOD2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次优化+偷懒写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc4</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ll sa = accumulate(a[i], a[i] + m, <span class="number">0l</span>l);</span><br><span class="line">        ll sb = accumulate(b[i], b[i] + m, <span class="number">0l</span>l);</span><br><span class="line">        ll si = sa * sb;</span><br><span class="line">        s += si;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= MOD2) s -= MOD2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出，在每层for里，calc1一共有4次取模，calc2只有1次取模。通过在线编译查看编译后的汇编代码，<a href="https://gcc.godbolt.org/" target="_blank" rel="noopener">https://gcc.godbolt.org/</a>，对比这2个代码的汇编，也可以确认calc1执行了4次取模。由于CPU对于取模的运算耗时是巨大的，所以降低取模次数，可以很好的降低常数。</p>
<p>一次优化原理如下，由于 $\sum_{j=1}^m {a_{ij}}  $ 和 $ \sum_{j=1}^m {b_{ij}}$ 都在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^{8}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 范围内，所以可以用 <code>long long</code> 存下，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>a</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>b</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="false">)</mo><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>16</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">s_i = (\sum_{j=1}^m {a_{ij}}) \times (\sum_{j=1}^m {b_{ij}}) \in [0, 10^{16}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mopen">(</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 也可以用 <code>long long</code> 存下，但由于最终的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 是在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, 10^{20}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 超出了 <code>long long</code>的表达范围，所以需要对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的加法结果进行取模。</p>
<p>二次优化原理如下，由于实际<code>long long</code>可以表达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-2^{63}, 2^{63}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 范围，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">2^{63}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> 约等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">9*10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>。我们可以使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>O</mi><msup><mi>D</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">MOD^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 的模数，最终返回的时候再对 MOD 取模一次，正确性可以通过数论证明，这里不做展开，那么 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 只有大约 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>100</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的概率实际需要进行取模，在平时题目中，这个概率是不确定的但往往是比较小的一个概率，那么使用 if 来判定然后做减法，往往会比取模效率提高非常多。</p>
<p>二次优化+偷懒原理如下，由于这种求和操作非常普通，但往往写起来需要时间，赛场上的任何一秒钟都是重要的，而且为了防止自己写错，可以使用C++ algorithm 中的 accumulate 函数来进行求和操作。accumulate 函数具体用法参考以下手册链接。<br />
<a href="https://zh.cppreference.com/w/cpp/algorithm/accumulate" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/algorithm/accumulate</a></p>
<h1 id="空间优化技巧"><a class="markdownIt-Anchor" href="#空间优化技巧"></a> 空间优化技巧</h1>
<h2 id="2倍空间线段树"><a class="markdownIt-Anchor" href="#2倍空间线段树"></a> 2倍空间线段树</h2>
<p>在普通的线段树写法中，线段树空间都是需要开4倍才能保证正确性的，这里我不做展开证明。<br />
但如果4倍空间开不下怎么办，那么我有一个2倍空间的线段树写法，并且可以数学证明正确性。<br />
这种写法会带来 %5 ~ %10的性能损耗，但却可以有一个全新的方法访问线段树中的任意一个[l, r]节点，前提该线段树中存在该区间的节点。例如可以方便的访问叶子节点，具体有什么用途未知，但可以发挥想象，万一哪天就用到了呢。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
</search>
